{"version":3,"file":"index.js","sources":["../../src/XSDAssembler.ts","../../src/XSDLoader.ts","../../src/XSDIncludeResolver.ts","../../src/XSDPropertyMerger.ts","../../src/MergeStrategies/OverwriteDuplicates.ts","../../src/index.ts","../../src/XSDAssemblerBuilder.ts"],"sourcesContent":["import { XSDLoader } from './XSDLoader';\nimport { XSDIncludeResolver } from './XSDIncludeResolver';\nimport { XSDPropertyMerger } from './XSDPropertyMerger';\nimport { XSDAssemblerImpl } from '@Protocols';\nimport path from 'path';\n\nexport class XSDAssembler implements XSDAssemblerImpl{\n    private loader: XSDLoader;\n    private resolver: XSDIncludeResolver;\n    private merger: XSDPropertyMerger;\n\n    constructor(loader: XSDLoader, resolver: XSDIncludeResolver, merger: XSDPropertyMerger) {\n        this.loader = loader;\n        this.resolver = resolver;\n        this.merger = merger;\n    }\n\n    async assemble(filePath: string): Promise<string> {\n        // Resolve todas as inclusões e aplica atributos no primeiro xs:schema\n        const resolvedSchema = await this.resolver.resolveIncludes(filePath, true, path.dirname(filePath));\n\n        // Mescla quaisquer propriedades adicionais usando o XSDPropertyMerger\n        const mergedSchema = this.merger.mergeProperties(resolvedSchema);\n\n        return mergedSchema;\n    }\n}\n","import { XSDLoaderImpl } from './protocols';\nimport fs from 'fs';\n\nexport class XSDLoader implements XSDLoaderImpl {\n    private schemaAttributes: { [key: string]: string } = {};\n\n    private extractSchemaAttributes(schemaContent: string) {\n        const schemaTagMatch = schemaContent.match(/<xs:schema([^>]*)>/i);\n        if (schemaTagMatch) {\n            const attributes = schemaTagMatch[1].trim().split(/\\s+/);\n            for (const attr of attributes) {\n                const [key, value] = attr.split('=');\n                if (key && value && !this.schemaAttributes[key]) {\n                    this.schemaAttributes[key] = value;\n                }\n            }\n        }\n    }\n\n    private mergeSchemaAttributes(schemaContent: string) {\n        const schemaTagMatch = schemaContent.match(/<xs:schema([^>]*)>/i);\n        if (schemaTagMatch) {\n            const attributes = schemaTagMatch[1].trim().split(/\\s+/);\n            for (const attr of attributes) {\n                const [key, value] = attr.split('=');\n                if (key && value && !this.schemaAttributes[key]) {\n                    this.schemaAttributes[key] = value;\n                }\n            }\n        }\n    }\n\n    public getSchemaAttributes(): { [key: string]: string } {\n        return this.schemaAttributes;\n    }\n\n    async load(filePath: string, firstFile: boolean): Promise<string> {\n        // console.log({filePath})\n        return new Promise((resolve, reject) => {\n            fs.readFile(filePath, 'utf8', (err, data) => {\n                if (err) {\n                    return reject(err);\n                }\n\n                if (firstFile) {\n                    this.extractSchemaAttributes(data); // Extrair atributos do primeiro xs:schema\n                } else {\n                    this.mergeSchemaAttributes(data); // Mesclar atributos dos demais xs:schema\n                }\n\n                // Remover declaração XML dos arquivos incluídos\n                if (!firstFile) {\n                    data = data.replace(/<\\?xml.*?\\?>\\s*/i, '');\n                }\n\n                // Remover tags <xs:schema> de arquivos incluídos\n                if (!firstFile) {\n                    data = data.replace(/<xs:schema[^>]*>/i, '').replace(/<\\/xs:schema>/i, '');\n                }\n\n                resolve(data);\n            });\n        });\n    }\n}\n","import { XSDLoader } from './XSDLoader';\nimport { XSDIncludeResolverImpl } from './protocols';\nimport path from 'path';\n\n\nexport class XSDIncludeResolver implements XSDIncludeResolverImpl {\n    private loader: XSDLoader;\n\n    constructor(loader: XSDLoader) {\n        this.loader = loader;\n    }\n\n    private applySchemaAttributes(schemaContent: string): string {\n        const schemaAttributes = this.loader.getSchemaAttributes();\n        const schemaTagMatch = schemaContent.match(/<xs:schema[^>]*>/i);\n        if (schemaTagMatch) {\n            const updatedSchemaTag = `<xs:schema ${Object.entries(schemaAttributes)\n                .map(([key, value]) => `${key}=${value}`)\n                .join(' ')}>`;\n            return schemaContent.replace(schemaTagMatch[0], updatedSchemaTag);\n        }\n        return schemaContent;\n    }\n\n    async resolveIncludes(filePath: string, firstFile = true, basePath = '.'): Promise<string> {\n        // Carrega o conteúdo inicial do XSD\n        let xsdContent = await this.loader.load(filePath, firstFile);\n\n        // Extrai e processa todas as inclusões recursivamente\n        const includeRegex = /<xs:include\\s+schemaLocation=\"([^\"]+)\"\\s*\\/?>/g;\n        let match;\n\n        while ((match = includeRegex.exec(xsdContent)) !== null) {\n            const includePath = path.resolve(basePath, match[1]);\n            const includedContent = await this.resolveIncludes(includePath, false, basePath);\n            xsdContent = xsdContent.replace(match[0], includedContent);\n        }\n\n        // Aplica atributos no primeiro arquivo\n        return firstFile ? this.applySchemaAttributes(xsdContent) : xsdContent;\n    }\n}\n","import { MergeStrategy } from './MergeStrategies/MergeStrategy';\nimport { XSDPropertyMergerImpl } from './protocols';\n\nexport class XSDPropertyMerger implements XSDPropertyMergerImpl {\n    private strategy: MergeStrategy;\n\n    constructor(strategy: MergeStrategy) {\n        this.strategy = strategy;\n    }\n\n    mergeProperties(schemaContent: string): string {\n        // Implementação fictícia de exemplo: pode adicionar ou mesclar propriedades do schema conforme necessário.\n        // Por exemplo, adicionar namespaces ou resolver conflitos de elementos.\n\n        // Aqui, apenas retornamos o conteúdo do schema como está.\n        return schemaContent;\n    }\n}\n","import { MergeStrategy } from './MergeStrategy';\n\nexport class OverwriteDuplicates implements MergeStrategy {\n    merge(mainSchema: string, includedSchema: string): string {\n        // Implementação para sobrescrever duplicatas\n        return `${includedSchema}`;\n    }\n}\n","import { XSDAssemblerBuilder } from './XSDAssemblerBuilder';\n\nconst xsdAssemblerBuilder = new XSDAssemblerBuilder();\n\nexport default xsdAssemblerBuilder;\n","import { XSDAssembler } from './XSDAssembler';\nimport { XSDLoader } from './XSDLoader';\nimport { XSDIncludeResolver } from './XSDIncludeResolver';\nimport { XSDPropertyMerger } from './XSDPropertyMerger';\nimport { MergeStrategy } from './MergeStrategies/MergeStrategy';\nimport { OverwriteDuplicates } from './MergeStrategies/OverwriteDuplicates';\nimport { XSDAssemblerBuilderImpl } from '@Protocols/XSDAssemblerBuilderImpl';\n\nexport class XSDAssemblerBuilder implements XSDAssemblerBuilderImpl {\n    private loader: XSDLoader;\n    private resolver: XSDIncludeResolver;\n    private merger?: XSDPropertyMerger;\n\n    constructor() {\n        this.loader = new XSDLoader();\n        this.resolver = new XSDIncludeResolver(this.loader);\n        this.setMergeStrategy(new OverwriteDuplicates());\n    }\n\n    private setMergeStrategy(strategy: MergeStrategy): XSDAssemblerBuilder {\n        this.merger = new XSDPropertyMerger(strategy);\n        return this;\n    }\n\n    assemble(filePath: string): Promise<string> {\n        if (!this.merger) {\n            throw new Error(\"Merge strategy must be set before building XSDAssembler.\");\n        }\n\n        const xsdAssembler = new XSDAssembler(this.loader, this.resolver, this.merger);\n        return xsdAssembler.assemble(filePath);\n    }\n}\n"],"names":["XSDAssembler","constructor","loader","resolver","merger","this","assemble","filePath","resolvedSchema","resolveIncludes","path","dirname","mergeProperties","XSDLoader","schemaAttributes","extractSchemaAttributes","schemaContent","schemaTagMatch","match","attributes","trim","split","attr","key","value","mergeSchemaAttributes","getSchemaAttributes","load","firstFile","Promise","resolve","reject","fs","readFile","err","data","replace","XSDIncludeResolver","applySchemaAttributes","updatedSchemaTag","Object","entries","map","join","basePath","xsdContent","includeRegex","exec","includePath","includedContent","XSDPropertyMerger","strategy","OverwriteDuplicates","merge","mainSchema","includedSchema","xsdAssemblerBuilder","setMergeStrategy","Error","module","exports"],"mappings":"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"}