{"version":3,"file":"index.js","sources":["../../src/XSDAssembler.ts","../../src/XSDLoader.ts","../../src/XSDIncludeResolver.ts","../../src/XSDPropertyMerger.ts","../../src/MergeStrategies/OverwriteDuplicates.ts","../../src/index.ts","../../src/XSDAssemblerBuilder.ts"],"sourcesContent":["import { XSDLoader } from './XSDLoader';\nimport { XSDIncludeResolver } from './XSDIncludeResolver';\nimport { XSDPropertyMerger } from './XSDPropertyMerger';\nimport { XSDAssemblerImpl } from '@Protocols';\nimport path from 'path';\n\nexport class XSDAssembler implements XSDAssemblerImpl{\n    private loader: XSDLoader;\n    private resolver: XSDIncludeResolver;\n    private merger: XSDPropertyMerger;\n\n    constructor(loader: XSDLoader, resolver: XSDIncludeResolver, merger: XSDPropertyMerger) {\n        this.loader = loader;\n        this.resolver = resolver;\n        this.merger = merger;\n    }\n\n    async assemble(filePath: string): Promise<string> {\n        // Resolve todas as inclusões e aplica atributos no primeiro xs:schema\n        const resolvedSchema = await this.resolver.resolveIncludes(filePath, true, path.dirname(filePath));\n    \n        // Normalizar as expressões regulares, removendo a duplicação das barras invertidas\n        const normalizedSchema = this.normalizeRegexPatterns(resolvedSchema);\n    \n        // Mescla quaisquer propriedades adicionais usando o XSDPropertyMerger\n        const mergedSchema = this.merger.mergeProperties(normalizedSchema);\n    \n        return mergedSchema;\n    }\n    \n    // Função para normalizar as expressões regulares\n    private normalizeRegexPatterns(schemaContent: string): string {\n        // Substitui as ocorrências de \\\\ por \\ (remover escape extra de barras invertidas)\n        return schemaContent.replace(/\\\\\\\\/g, '\\\\');\n    }\n}\n","import { XSDLoaderImpl } from './protocols';\nimport fs from 'fs';\n\nexport class XSDLoader implements XSDLoaderImpl {\n    private schemaAttributes: { [key: string]: string } = {};\n\n    private extractSchemaAttributes(schemaContent: string) {\n        const schemaTagMatch = schemaContent.match(/<xs:schema([^>]*)>/i);\n        if (schemaTagMatch) {\n            const attributes = schemaTagMatch[1].trim().split(/\\s+/);\n            for (const attr of attributes) {\n                const [key, value] = attr.split('=');\n                if (key && value && !this.schemaAttributes[key]) {\n                    this.schemaAttributes[key] = value;\n                }\n            }\n        }\n    }\n\n    private mergeSchemaAttributes(schemaContent: string) {\n        const schemaTagMatch = schemaContent.match(/<xs:schema([^>]*)>/i);\n        if (schemaTagMatch) {\n            const attributes = schemaTagMatch[1].trim().split(/\\s+/);\n            for (const attr of attributes) {\n                const [key, value] = attr.split('=');\n                if (key && value && !this.schemaAttributes[key]) {\n                    this.schemaAttributes[key] = value;\n                }\n            }\n        }\n    }\n\n    public getSchemaAttributes(): { [key: string]: string } {\n        return this.schemaAttributes;\n    }\n\n    async load(filePath: string, firstFile: boolean): Promise<string> {\n        // console.log({filePath})\n        return new Promise((resolve, reject) => {\n            fs.readFile(filePath, 'utf8', (err, data) => {\n                if (err) {\n                    return reject(err);\n                }\n\n                if (firstFile) {\n                    this.extractSchemaAttributes(data); // Extrair atributos do primeiro xs:schema\n                } else {\n                    this.mergeSchemaAttributes(data); // Mesclar atributos dos demais xs:schema\n                }\n\n                // Remover declaração XML dos arquivos incluídos\n                if (!firstFile) {\n                    data = data.replace(/<\\?xml.*?\\?>\\s*/i, '');\n                }\n\n                // Remover tags <xs:schema> de arquivos incluídos\n                if (!firstFile) {\n                    data = data.replace(/<xs:schema[^>]*>/i, '').replace(/<\\/xs:schema>/i, '');\n                }\n\n                resolve(data);\n            });\n        });\n    }\n}\n","import { XSDLoader } from './XSDLoader';\nimport { XSDIncludeResolverImpl } from './protocols';\nimport path from 'path';\n\nexport class XSDIncludeResolver implements XSDIncludeResolverImpl {\n    private loader: XSDLoader;\n\n    constructor(loader: XSDLoader) {\n        this.loader = loader;\n    }\n\n    private applySchemaAttributes(schemaContent: string): string {\n        const schemaAttributes = this.loader.getSchemaAttributes();\n        const schemaTagMatch = schemaContent.match(/<xs:schema[^>]*>/i);\n        if (schemaTagMatch) {\n            const updatedSchemaTag = `<xs:schema ${Object.entries(schemaAttributes)\n                .map(([key, value]) => `${key}=${value}`)\n                .join(' ')}>`;\n            return schemaContent.replace(schemaTagMatch[0], updatedSchemaTag);\n        }\n        return schemaContent;\n    }\n\n    // Função para reorganizar diretivas <xs:import> e <xs:include>\n    private reorderSchemaDirectives(schemaContent: string): string {\n        // Extrai todas as diretivas <xs:import> e <xs:include>\n        const importRegex = /<xs:import[^>]*\\/>/g;\n        const includeRegex = /<xs:include[^>]*\\/>/g;\n    \n        const imports = [...schemaContent.match(importRegex) || []];\n        const includes = [...schemaContent.match(includeRegex) || []];\n    \n        // Remove as diretivas do conteúdo original\n        let updatedSchema = schemaContent\n            .replace(importRegex, '')\n            .replace(includeRegex, '');\n    \n        // Identifica o fim da tag de abertura <xs:schema>\n        const schemaOpenTagMatch = updatedSchema.match(/<xs:schema[^>]*>/i);\n        if (!schemaOpenTagMatch) {\n            throw new Error(\"A tag <xs:schema> não foi encontrada no conteúdo do schema.\");\n        }\n    \n        const schemaOpenTag = schemaOpenTagMatch[0];\n        const schemaOpenTagEndIndex = updatedSchema.indexOf(schemaOpenTag) + schemaOpenTag.length;\n    \n        // Separa o conteúdo antes e depois da tag <xs:schema>\n        const schemaStart = updatedSchema.slice(0, schemaOpenTagEndIndex);\n        const schemaRest = updatedSchema.slice(schemaOpenTagEndIndex);\n    \n        // Reinsere as diretivas após a abertura da tag <xs:schema>\n        return `${schemaStart}\\n${imports.join('\\n')}\\n${includes.join('\\n')}\\n${schemaRest}`;\n    }\n\n    // Resolve recursivamente <xs:include> e aplica os atributos no primeiro arquivo\n    async resolveIncludes(filePath: string, firstFile = true, basePath = '.'): Promise<string> {\n        // Carrega o conteúdo inicial do XSD\n        let xsdContent = await this.loader.load(filePath, firstFile);\n\n        // Extrai e processa todas as inclusões recursivamente\n        const includeRegex = /<xs:include\\s+schemaLocation=\"([^\"]+)\"\\s*\\/?>/g;\n        let match;\n\n        while ((match = includeRegex.exec(xsdContent)) !== null) {\n            const includePath = path.resolve(basePath, match[1]);\n            const includedContent = await this.resolveIncludes(includePath, false, basePath);\n            xsdContent = xsdContent.replace(match[0], includedContent);\n        }\n\n        // Aplica atributos e reorganiza as diretivas no primeiro arquivo\n        if (firstFile) {\n            xsdContent = this.applySchemaAttributes(xsdContent); // Aplica atributos ao primeiro xs:schema\n            xsdContent = this.reorderSchemaDirectives(xsdContent); // Reorganiza as diretivas\n        }\n\n        return xsdContent;\n    }\n}\n","import { MergeStrategy } from './MergeStrategies/MergeStrategy';\nimport { XSDPropertyMergerImpl } from './protocols';\n\nexport class XSDPropertyMerger implements XSDPropertyMergerImpl {\n    private strategy: MergeStrategy;\n\n    constructor(strategy: MergeStrategy) {\n        this.strategy = strategy;\n    }\n\n    mergeProperties(schemaContent: string): string {\n        // Implementação fictícia de exemplo: pode adicionar ou mesclar propriedades do schema conforme necessário.\n        // Por exemplo, adicionar namespaces ou resolver conflitos de elementos.\n\n        // Aqui, apenas retornamos o conteúdo do schema como está.\n        return schemaContent;\n    }\n}\n","import { MergeStrategy } from './MergeStrategy';\n\nexport class OverwriteDuplicates implements MergeStrategy {\n    merge(mainSchema: string, includedSchema: string): string {\n        // Implementação para sobrescrever duplicatas\n        return `${includedSchema}`;\n    }\n}\n","import { XSDAssemblerBuilder } from './XSDAssemblerBuilder';\n\nconst xsdAssemblerBuilder = new XSDAssemblerBuilder();\n\nexport default xsdAssemblerBuilder;\n","import { XSDAssembler } from './XSDAssembler';\nimport { XSDLoader } from './XSDLoader';\nimport { XSDIncludeResolver } from './XSDIncludeResolver';\nimport { XSDPropertyMerger } from './XSDPropertyMerger';\nimport { MergeStrategy } from './MergeStrategies/MergeStrategy';\nimport { OverwriteDuplicates } from './MergeStrategies/OverwriteDuplicates';\nimport { XSDAssemblerBuilderImpl } from '@Protocols/XSDAssemblerBuilderImpl';\n\nexport class XSDAssemblerBuilder implements XSDAssemblerBuilderImpl {\n    private loader: XSDLoader;\n    private resolver: XSDIncludeResolver;\n    private merger?: XSDPropertyMerger;\n\n    constructor() {\n        this.loader = new XSDLoader();\n        this.resolver = new XSDIncludeResolver(this.loader);\n        this.setMergeStrategy(new OverwriteDuplicates());\n    }\n\n    private setMergeStrategy(strategy: MergeStrategy): XSDAssemblerBuilder {\n        this.merger = new XSDPropertyMerger(strategy);\n        return this;\n    }\n\n    assemble(filePath: string): Promise<string> {\n        if (!this.merger) {\n            throw new Error(\"Merge strategy must be set before building XSDAssembler.\");\n        }\n\n        const xsdAssembler = new XSDAssembler(this.loader, this.resolver, this.merger);\n        return xsdAssembler.assemble(filePath);\n    }\n}\n"],"names":["XSDAssembler","constructor","loader","resolver","merger","this","assemble","filePath","resolvedSchema","resolveIncludes","path","dirname","normalizedSchema","normalizeRegexPatterns","mergeProperties","schemaContent","replace","XSDLoader","schemaAttributes","extractSchemaAttributes","schemaTagMatch","match","attributes","trim","split","attr","key","value","mergeSchemaAttributes","getSchemaAttributes","load","firstFile","Promise","resolve","reject","fs","readFile","err","data","XSDIncludeResolver","applySchemaAttributes","updatedSchemaTag","Object","entries","map","join","reorderSchemaDirectives","importRegex","includeRegex","imports","includes","updatedSchema","schemaOpenTagMatch","Error","schemaOpenTag","schemaOpenTagEndIndex","indexOf","length","schemaStart","slice","schemaRest","basePath","xsdContent","exec","includePath","includedContent","XSDPropertyMerger","strategy","OverwriteDuplicates","merge","mainSchema","includedSchema","xsdAssemblerBuilder","setMergeStrategy","module","exports"],"mappings":"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"}